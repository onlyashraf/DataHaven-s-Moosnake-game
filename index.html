<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Moosnake Game with Key Power-Up</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    body {
      background: url("better.png") no-repeat center center fixed;
      background-size: cover;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      text-align: center;
    }
    #logo {
      display: block;
      margin: 10px auto;
      width: 100px;
      height: auto;
    }
    h1 {
      font-family: 'Press Start 2P', cursive;
      font-size: 22px;
      color: #ffb703;
      text-shadow: 3px 3px 0px #fb8500, 6px 6px 0px #023047;
      margin-bottom: 5px;
      letter-spacing: 2px;
    }
    h2 {
      font-family: 'Press Start 2P', cursive;
      font-size: 14px;
      color: #fb8500;
      text-shadow: 1px 1px 0px #023047;
      margin-bottom: 15px;
      letter-spacing: 1px;
    }

    .game-container {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      gap: 20px;
      margin-top: 10px;
      flex-wrap: wrap;
      max-width: 100%;
    }

    /* wrapper that will be requestFullscreen()'d */
    .game-wrapper {
      position: relative;
      display: inline-block;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0px 0px 25px rgba(0,0,0,0.6);
      background: linear-gradient(145deg, #0d1b2a, #1b263b);
    }

    /* make wrapper fill viewport when we add the fullscreen class or when it's actually fullscreen */
    .game-wrapper.fullscreen,
    .game-wrapper:fullscreen,
    .game-wrapper:-webkit-full-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 9999;
      border-radius: 0;
      box-shadow: none;
    }

    /* mobile-specific solid color overlay */
    .game-wrapper.fullscreen-mobile {
      background: #0d1b2a;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      border: 3px solid #415a77;
      border-radius: 15px;
      box-sizing: border-box;
      touch-action: none;
      background: transparent; /* wrapper already has gradient */
    }

    /* NEW: Add a visible border for fullscreen mobile */
    .game-wrapper.fullscreen-mobile canvas {
        border: 5px solid #ffb703 !important;
    }


    /* Score overlay inside wrapper (so it stays visible in fullscreen) */
    #scoreOverlay {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 10001;
      pointer-events: none;
    }

    #score {
      font-family: 'Press Start 2P', cursive;
      font-size: 16px;
      color: #212529;
      background: rgba(255, 255, 255, 0.85);
      padding: 6px 12px;
      border-radius: 8px;
      display: inline-block;
      pointer-events: none;
    }

    /* keep UI & side panel separate (we hide them via JS when fullscreen) */
    #ui {
      margin-top: 15px;
      text-align: center;
      z-index: 2;
      position: relative;
    }

    button {
      background: #ffb703;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      margin: 5px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s ease-in-out, transform 0.15s ease-in-out;
    }
    button:hover {
      background: #fb8500;
      transform: scale(1.05);
    }

    .side-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }
    .side-box {
      width: 180px;
      font-family: 'Press Start 2P', cursive;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.8);
      color: #023047;
      border: 2px solid #415a77;
      border-radius: 12px;
      padding: 10px;
      text-align: left;
      line-height: 1.5;
    }
    .side-box h3 {
      font-size: 12px;
      margin-bottom: 5px;
      text-align: center;
      color: #fb8500;
      text-shadow: 1px 1px 0px #023047;
    }
    #tomatoMan {
      width: 160px;
      height: auto;
      border-radius: 12px;
      border: 2px solid #415a77;
      box-shadow: 0px 0px 12px rgba(0,0,0,0.4);
    }

    /* Helpful responsive rules */
    @media (max-width: 768px) {
      .game-container {
        flex-direction: column;
        align-items: center;
        gap: 15px;
      }
      .side-box, .side-panel {
        width: 90%;
        text-align: center;
        font-size: 12px;
      }
      #ui button {
        font-size: 18px;
        padding: 12px 24px;
        width: 90%;
        max-width: 250px;
      }
      #score {
        font-size: 18px;
        padding: 10px 15px;
      }
    }

    /* Force hide UI when we add this class to body (fallback) */
    body.hide-ui #ui,
    body.hide-ui .side-panel {
      display: none !important;
    }
  </style>
</head>
<body>
  <img src="9YuEYF8-_400x400.jpg" alt="DataHaven Logo" id="logo">
  <h1>ü´é DataHaven's Moosnake Game</h1>
  <h2>BY: TOMATO MAN</h2>

  <div class="game-container">
    <div class="side-box">
      <h3>üéÆ Controls</h3>
      ‚Üë / W = Up<br>
      ‚Üì / S = Down<br>
      ‚Üê / A = Left<br>
      ‚Üí / D = Right<br>
      üëÜ Swipe = Mobile
    </div>

    <div id="gameWrapper" class="game-wrapper" style="width:600px;height:400px;">
      <canvas id="gameCanvas" width="600" height="400"></canvas>
      <div id="scoreOverlay"><div id="score">Score: 0</div></div>
    </div>

    <div class="side-panel">
      <div class="side-box">
        <h3>üìú Rules</h3>
        ü•ú Eat acorns = +1<br>
        üîë Grab key = +10<br>
        ‚ùå Don‚Äôt hit yourself<br>
        ‚è© Snake speeds up slowly<br>
        üåç Wrap around edges
      </div>
      <img src="Generated Image September 12, 2025 - 6_21PM.png" alt="Tomato Man" id="tomatoMan">
    </div>
  </div>

  <div id="ui">
    <button id="startBtn">Start Game</button>
    <button id="pauseBtn" style="display:none;">Pause</button>
    <button id="resumeBtn" style="display:none;">Resume</button>
    <button id="restartBtn" style="display:none;">Restart</button>
    <button id="fullscreenBtn">Fullscreen</button>
  </div>

  <script>
    // Elements
    const wrapper = document.getElementById("gameWrapper");
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const scoreEl = document.getElementById("score");
    const startBtn = document.getElementById("startBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const resumeBtn = document.getElementById("resumeBtn");
    const restartBtn = document.getElementById("restartBtn");
    const fullscreenBtn = document.getElementById("fullscreenBtn");

    // Grid & base
    let gridSize = 25;
    let cols = canvas.width / gridSize;
    let rows = canvas.height / gridSize;
    const baseCols = cols;
    const baseRows = rows;

    // Game state
    let snake, direction, nextDirection, food, score, gameInterval, gameRunning, speed;
    let key = null;
    let keyVisible = false;
    let keyTimer, keySpawnTimer;
    let fullscreen = false;

    // Images
    const acorn = new Image(); acorn.src = "acorn.png";
    const mooseHead = new Image(); mooseHead.src = "moose.png";
    const keyImg = new Image(); keyImg.src = "key.png";

    // Mobile detection
    function isMobile() {
      return /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
    }

    // Resize canvas to wrapper or default sizes
    function resizeCanvas() {
      // If wrapper is fullscreen or document is fullscreen, use viewport
      const docFS = !!document.fullscreenElement;
      const wrapperIsFS = document.fullscreenElement === wrapper;

      if (wrapper.classList.contains("fullscreen") || wrapperIsFS || docFS) {
        // ensure wrapper fills viewport
        const w = window.innerWidth;
        const h = window.innerHeight;
        wrapper.style.width = w + "px";
        wrapper.style.height = h + "px";
        // set canvas drawing buffer size
        canvas.width = w;
        canvas.height = h;
        canvas.style.width = "100%";
        canvas.style.height = "100%";
      } else if (window.innerWidth < 768) {
        const w = Math.floor(window.innerWidth * 0.9);
        const h = Math.floor(window.innerHeight * 0.5);
        canvas.width = w;
        canvas.height = h;
        wrapper.style.width = w + "px";
        wrapper.style.height = h + "px";
        canvas.style.width = "100%";
        canvas.style.height = "100%";
      } else {
        canvas.width = 600;
        canvas.height = 400;
        wrapper.style.width = "600px";
        wrapper.style.height = "400px";
        canvas.style.width = "100%";
        canvas.style.height = "100%";
      }

      gridSize = Math.max(4, Math.floor(Math.min(canvas.width / baseCols, canvas.height / baseRows)));
      cols = baseCols;
      rows = baseRows;
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // Game functions
    function resetGame() {
      snake = [{ x: 5, y: 5 }];
      direction = { x: 1, y: 0 };
      nextDirection = { x: 1, y: 0 };
      score = 0;
      speed = 150;
      scoreEl.textContent = "Score: " + score;
      placeFood();
      removeKey();
      scheduleKey();
    }

    function placeFood() {
      let valid = false;
      while (!valid) {
        food = { x: Math.floor(Math.random() * cols), y: Math.floor(Math.random() * rows) };
        valid = !snake.some(seg => seg.x === food.x && seg.y === food.y);
      }
    }

    function placeKey() {
      let valid = false;
      while (!valid) {
        key = { x: Math.floor(Math.random() * cols), y: Math.floor(Math.random() * rows) };
        valid = !snake.some(seg => seg.x === key.x && seg.y === key.y) &&
                !(food.x === key.x && food.y === key.y);
      }
      keyVisible = true;
      clearTimeout(keyTimer);
      keyTimer = setTimeout(removeKey, 8000);
    }

    function removeKey() {
      key = null;
      keyVisible = false;
      scheduleKey();
    }

    function scheduleKey() {
      clearTimeout(keySpawnTimer);
      keySpawnTimer = setTimeout(() => {
        if (!keyVisible) placeKey();
      }, 10000);
    }

    function drawSnake() {
      snake.forEach((segment, index) => {
        if (index === 0) drawMooseHead(segment.x, segment.y);
        else {
          ctx.fillStyle = "#219ebc";
          ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
        }
      });
    }

    function drawMooseHead(x, y) {
      const size = gridSize * 1.6;
      const cx = x * gridSize + gridSize / 2;
      const cy = y * gridSize + gridSize / 2;
      const imageRotationOffset = Math.PI / 2;
      const angle = Math.atan2(direction.y, direction.x) + imageRotationOffset;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(angle);
      // If moose image not loaded yet, draw a placeholder
      if (mooseHead.complete && mooseHead.naturalWidth !== 0) {
        ctx.drawImage(mooseHead, -size / 2, -size / 2, size, size);
      } else {
        ctx.fillStyle = "#ffd166";
        ctx.fillRect(-size/2, -size/2, size, size);
      }
      ctx.restore();
    }

    function drawFood() {
      if (acorn.complete && acorn.naturalWidth !== 0) {
        ctx.drawImage(acorn, food.x * gridSize, food.y * gridSize, gridSize, gridSize);
      } else {
        ctx.fillStyle = "#ffb703";
        ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize, gridSize);
      }
    }

    function drawKey() {
      if (keyVisible && key) {
        const size = gridSize * 1.2;
        if (keyImg.complete && keyImg.naturalWidth !== 0) {
          ctx.drawImage(keyImg, key.x * gridSize, key.y * gridSize, size, size);
        } else {
          ctx.fillStyle = "#ffd700";
          ctx.fillRect(key.x * gridSize, key.y * gridSize, size, size);
        }
      }
    }

    function update() {
      const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

      if (head.x < 0) head.x = cols - 1;
      if (head.x >= cols) head.x = 0;
      if (head.y < 0) head.y = rows - 1;
      if (head.y >= rows) head.y = 0;

      if (snake.some(seg => seg.x === head.x && seg.y === head.y)) {
        gameOver();
        return;
      }

      snake.unshift(head);

      if (head.x === food.x && head.y === food.y) {
        score++;
        scoreEl.textContent = "Score: " + score;
        placeFood();
        speed = Math.max(100, 150 * Math.pow(0.99, score));
        clearInterval(gameInterval);
        gameInterval = setInterval(gameLoop, speed);
      } else if (keyVisible && key && head.x === key.x && head.y === key.y) {
        score += 10;
        scoreEl.textContent = "Score: " + score;
        removeKey();
      } else {
        snake.pop();
      }

      direction = nextDirection;
    }

    function draw() {
      // draw gradient/background on the drawing buffer
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      gradient.addColorStop(0, "#0d1b2a");
      gradient.addColorStop(1, "#1b263b");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // scaling: game coordinates are based on gridSize & base cols/rows
      // We'll draw using the gridSize multiplier
      drawFood();
      drawKey();
      drawSnake();
    }

    function gameLoop() {
      update();
      draw();
    }

    function startGame() {
      resetGame();
      gameRunning = true;
      startBtn.style.display = "none";
      pauseBtn.style.display = "inline-block";
      resumeBtn.style.display = "none";
      restartBtn.style.display = "none";
      clearInterval(gameInterval);
      gameInterval = setInterval(gameLoop, speed);
    }

    function pauseGame() {
      clearInterval(gameInterval);
      gameRunning = false;
      pauseBtn.style.display = "none";
      resumeBtn.style.display = "inline-block";
    }

    function resumeGame() {
      if (!gameRunning) {
        gameRunning = true;
        gameInterval = setInterval(gameLoop, speed);
        pauseBtn.style.display = "inline-block";
        resumeBtn.style.display = "none";
      }
    }

    function gameOver() {
      clearInterval(gameInterval);
      gameRunning = false;
      // keep it simple ‚Äî alert
      alert("Game Over!\nScore: " + score);
      restartBtn.style.display = "inline-block";
      pauseBtn.style.display = "none";
      resumeBtn.style.display = "none";
    }

    // Input handlers
    document.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if ((k === "arrowup" || k === "w") && direction.y !== 1) nextDirection = { x: 0, y: -1 };
      if ((k === "arrowdown" || k === "s") && direction.y !== -1) nextDirection = { x: 0, y: 1 };
      if ((k === "arrowleft" || k === "a") && direction.x !== 1) nextDirection = { x: -1, y: 0 };
      if ((k === "arrowright" || k === "d") && direction.x !== -1) nextDirection = { x: 1, y: 0 };
    });

    // Touch swipe
    let touchStartX = 0, touchStartY = 0, touchEndX = 0, touchEndY = 0;
    canvas.addEventListener("touchstart", (e) => {
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
    }, {passive:true});
    canvas.addEventListener("touchend", (e) => {
      const touch = e.changedTouches[0];
      touchEndX = touch.clientX;
      touchEndY = touch.clientY;
      handleSwipe();
    }, {passive:true});
    function handleSwipe() {
      const dx = touchEndX - touchStartX;
      const dy = touchEndY - touchStartY;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 30 && direction.x !== -1) nextDirection = { x: 1, y: 0 };
        if (dx < -30 && direction.x !== 1) nextDirection = { x: -1, y: 0 };
      } else {
        if (dy > 30 && direction.y !== -1) nextDirection = { x: 0, y: 1 };
        if (dy < -30 && direction.y !== 1) nextDirection = { x: 0, y: -1 };
      }
    }

    // Fullscreen handling (request fullscreen on the wrapper so score stays visible)
    function enterFullscreen() {
      // prefer wrapper element fullscreen
      if (wrapper.requestFullscreen) wrapper.requestFullscreen();
      else if (wrapper.webkitRequestFullscreen) wrapper.webkitRequestFullscreen();
      else if (canvas.requestFullscreen) canvas.requestFullscreen();
      else if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
    }
    function exitFullscreen() {
      if (document.exitFullscreen) document.exitFullscreen();
      else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
    }

    fullscreenBtn.addEventListener("click", () => {
      if (!fullscreen) enterFullscreen();
      else exitFullscreen();
    });

    // fullscreen change: add classes, resize, hide UI
    document.addEventListener("fullscreenchange", () => {
      fullscreen = !!document.fullscreenElement;
      const docFS = document.fullscreenElement;
      const wrapperIsFS = docFS === wrapper;

      if (fullscreen) {
        // mark body to hide UI (fallback)
        document.body.classList.add("hide-ui");

        // add fullscreen classes to wrapper for styles and mobile overlay
        wrapper.classList.add("fullscreen");
        if (isMobile()) wrapper.classList.add("fullscreen-mobile");
        else wrapper.classList.remove("fullscreen-mobile");

        // hide the buttons explicitly (they'll be outside wrapper, but we hide as fallback)
        [...document.querySelectorAll("#ui button")].forEach(btn => btn.style.display = "none");
        // hide side panel
        const sp = document.querySelector(".side-panel");
        if (sp) sp.style.display = "none";
      } else {
        document.body.classList.remove("hide-ui");
        wrapper.classList.remove("fullscreen", "fullscreen-mobile");
        // restore UI displays
        [...document.querySelectorAll("#ui button")].forEach(btn => btn.style.display = "");
        const sp = document.querySelector(".side-panel");
        if (sp) sp.style.display = "";
      }

      // Force canvas/wrapper sizing update
      resizeCanvas();

      // NEW: Force border and remove rounded corners in fullscreen
      canvas.style.borderRadius = (fullscreen ? "0" : "15px");
      if (fullscreen && !isMobile()) {
          canvas.style.border = "3px solid #415a77";
      } else if (!fullscreen) {
          canvas.style.border = "3px solid #415a77";
      }
    });

    // Wire buttons
    startBtn.addEventListener("click", startGame);
    pauseBtn.addEventListener("click", pauseGame);
    resumeBtn.addEventListener("click", resumeGame);
    restartBtn.addEventListener("click", startGame);

    // initialize
    resetGame();
  </script>
</body>
</html>
