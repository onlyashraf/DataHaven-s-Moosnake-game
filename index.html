<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Moosnake Game with Key Power-Up</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    body {
      background: url("better.png") no-repeat center center fixed;
      background-size: cover;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      text-align: center;
    }
    #logo {
      display: block;
      margin: 10px auto;
      width: 100px;
      height: auto;
    }
    h1 {
      font-family: 'Press Start 2P', cursive;
      font-size: 22px;
      color: #ffb703;
      text-shadow: 3px 3px 0px #fb8500, 6px 6px 0px #023047;
      margin-bottom: 5px;
      letter-spacing: 2px;
    }
    h2 {
      font-family: 'Press Start 2P', cursive;
      font-size: 14px;
      color: #fb8500;
      text-shadow: 1px 1px 0px #023047;
      margin-bottom: 15px;
      letter-spacing: 1px;
    }
    .game-container {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      gap: 20px;
      margin-top: 10px;
      flex-wrap: wrap;
      max-width: 100%;
    }
    canvas {
      background: linear-gradient(145deg, #0d1b2a, #1b263b);
      border: 3px solid #415a77;
      border-radius: 15px;
      box-shadow: 0px 0px 25px rgba(0, 0, 0, 0.6),
                  0px 0px 50px rgba(65, 90, 119, 0.4) inset;
      display: block;
      max-width: 100%;
      height: auto;
      touch-action: none;
    }
    #ui {
      margin-top: 15px;
      text-align: center;
    }
    #score {
      display: none; /* now we draw score inside canvas */
    }
    button {
      background: #ffb703;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      margin: 5px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s ease-in-out, transform 0.15s ease-in-out;
    }
    button:hover {
      background: #fb8500;
      transform: scale(1.05);
    }
    .side-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }
    .side-box {
      width: 180px;
      font-family: 'Press Start 2P', cursive;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.8);
      color: #023047;
      border: 2px solid #415a77;
      border-radius: 12px;
      padding: 10px;
      text-align: left;
      line-height: 1.5;
    }
    .side-box h3 {
      font-size: 12px;
      margin-bottom: 5px;
      text-align: center;
      color: #fb8500;
      text-shadow: 1px 1px 0px #023047;
    }
    #tomatoMan {
      width: 160px;
      height: auto;
      border-radius: 12px;
      border: 2px solid #415a77;
      box-shadow: 0px 0px 12px rgba(0,0,0,0.4);
    }
  </style>
</head>
<body>
  <img src="9YuEYF8-_400x400.jpg" alt="DataHaven Logo" id="logo">
  <h1>🫎 DataHaven's Moosnake Game</h1>
  <h2>BY: TOMATO MAN</h2>

  <div class="game-container">
    <div class="side-box">
      <h3>🎮 Controls</h3>
      ↑ / W = Up<br>
      ↓ / S = Down<br>
      ← / A = Left<br>
      → / D = Right<br>
      👆 Swipe = Mobile
    </div>

    <canvas id="gameCanvas" width="600" height="400"></canvas>

    <div class="side-panel">
      <div class="side-box">
        <h3>📜 Rules</h3>
        🥜 Eat acorns = +1<br>
        🔑 Grab key = +10<br>
        ❌ Don’t hit yourself<br>
        ⏩ Snake speeds up slowly<br>
        🌍 Wrap around edges
      </div>
      <img src="Generated Image September 12, 2025 - 6_21PM.png" alt="Tomato Man" id="tomatoMan">
    </div>
  </div>

  <div id="ui">
    <button id="startBtn">Start Game</button>
    <button id="pauseBtn" style="display:none;">Pause</button>
    <button id="resumeBtn" style="display:none;">Resume</button>
    <button id="restartBtn" style="display:none;">Restart</button>
    <button id="fullscreenBtn">Fullscreen</button>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const startBtn = document.getElementById("startBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const resumeBtn = document.getElementById("resumeBtn");
    const restartBtn = document.getElementById("restartBtn");
    const fullscreenBtn = document.getElementById("fullscreenBtn");

    let gridSize = 25;
    let cols = canvas.width / gridSize;
    let rows = canvas.height / gridSize;
    const baseCols = cols;
    const baseRows = rows;

    let snake, direction, nextDirection, food, score, gameInterval, gameRunning, speed;

    const acorn = new Image();
    acorn.src = "acorn.png";
    const mooseHead = new Image();
    mooseHead.src = "moose.png";
    const keyImg = new Image();
    keyImg.src = "key.png";

    let key = null;
    let keyVisible = false;
    let keyTimer, keySpawnTimer;
    let fullscreen = false;

    function resizeCanvas() {
      if (fullscreen) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      } else if (window.innerWidth < 768) {
        canvas.width = Math.floor(window.innerWidth * 0.9);
        canvas.height = Math.floor(window.innerHeight * 0.5);
      } else {
        canvas.width = 600;
        canvas.height = 400;
      }
      gridSize = Math.floor(Math.min(canvas.width / baseCols, canvas.height / baseRows));
      cols = Math.floor(canvas.width / gridSize); // Recalculate cols and rows
      rows = Math.floor(canvas.height / gridSize);
    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    function resetGame() {
      snake = [{ x: 5, y: 5 }];
      direction = { x: 1, y: 0 };
      nextDirection = { x: 1, y: 0 };
      score = 0;
      speed = 150;
      placeFood();
      removeKey();
      scheduleKey();
    }

    function placeFood() {
      let valid = false;
      while (!valid) {
        food = { x: Math.floor(Math.random() * cols), y: Math.floor(Math.random() * rows) };
        valid = !snake.some(seg => seg.x === food.x && seg.y === food.y);
        if (food.y < 2) valid = false;
      }
    }

    function placeKey() {
      let valid = false;
      while (!valid) {
        key = { x: Math.floor(Math.random() * cols), y: Math.floor(Math.random() * rows) };
        valid = !snake.some(seg => seg.x === key.x && seg.y === key.y) &&
                !(food.x === key.x && food.y === key.y);
        if (key.y < 2) valid = false;
      }
      keyVisible = true;
      clearTimeout(keyTimer);
      keyTimer = setTimeout(removeKey, 8000);
    }

    function removeKey() {
      key = null;
      keyVisible = false;
      scheduleKey();
    }

    function scheduleKey() {
      clearTimeout(keySpawnTimer);
      keySpawnTimer = setTimeout(() => {
        if (!keyVisible) placeKey();
      }, 10000);
    }

    function drawGrid() {
      ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
      ctx.lineWidth = 1;
      for (let x = 0; x <= cols; x++) {
        ctx.beginPath();
        ctx.moveTo(x * gridSize, 0);
        ctx.lineTo(x * gridSize, rows * gridSize);
        ctx.stroke();
      }
      for (let y = 0; y <= rows; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * gridSize);
        ctx.lineTo(cols * gridSize, y * gridSize);
        ctx.stroke();
      }
      ctx.strokeStyle = "#ffb703";
      ctx.lineWidth = 3;
      ctx.strokeRect(0, 0, cols * gridSize, rows * gridSize);
    }

    function drawSnake() {
      snake.forEach((segment, index) => {
        if (index === 0) drawMooseHead(segment.x, segment.y);
        else {
          ctx.fillStyle = "#219ebc";
          ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
        }
      });
    }

    function drawMooseHead(x, y) {
      const size = gridSize * 1.6;
      const cx = x * gridSize + gridSize / 2;
      const cy = y * gridSize + gridSize / 2;
      const imageRotationOffset = Math.PI / 2;
      const angle = Math.atan2(direction.y, direction.x) + imageRotationOffset;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(angle);
      ctx.drawImage(mooseHead, -size / 2, -size / 2, size, size);
      ctx.restore();
    }

    function drawFood() {
      ctx.drawImage(acorn, food.x * gridSize, food.y * gridSize, gridSize, gridSize);
    }

    function drawKey() {
      if (keyVisible && key) {
        const size = gridSize * 1.2;
        ctx.shadowColor = "#ffd700";
        ctx.shadowBlur = 15;
        ctx.drawImage(keyImg, key.x * gridSize, key.y * gridSize, size, size);
        ctx.shadowBlur = 0;
      }
    }

    function drawScore() {
      ctx.fillStyle = "rgba(0,0,0,0.5)";
      ctx.fillRect(5, 5, 160, 30);
      ctx.fillStyle = "white";
      ctx.font = "16px 'Press Start 2P', cursive";
      ctx.textAlign = "left";
      ctx.fillText("Score: " + score, 15, 28);
    }

    // New function to draw the start button on the canvas
    function drawStartButton() {
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const btnWidth = 200;
        const btnHeight = 60;
        const btnX = (canvas.width / 2) - (btnWidth / 2);
        const btnY = (canvas.height / 2) - (btnHeight / 2);
        ctx.fillStyle = "#ffb703";
        ctx.fillRect(btnX, btnY, btnWidth, btnHeight);

        ctx.fillStyle = "#023047";
        ctx.font = "24px 'Press Start 2P', cursive";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("Start Game", canvas.width / 2, canvas.height / 2);
    }

    function update() {
      const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
      if (head.x < 0) head.x = cols - 1;
      if (head.x >= cols) head.x = 0;
      if (head.y < 0) head.y = rows - 1;
      if (head.y >= rows) head.y = 0;

      if (snake.some(seg => seg.x === head.x && seg.y === head.y)) {
        gameOver();
        return;
      }

      snake.unshift(head);

      if (head.x === food.x && head.y === food.y) {
        score++;
        placeFood();
        speed = Math.max(100, 150 * Math.pow(0.99, score));
        clearInterval(gameInterval);
        gameInterval = setInterval(gameLoop, speed);
      } else if (keyVisible && key && head.x === key.x && head.y === key.y) {
        score += 10;
        removeKey();
      } else {
        snake.pop();
      }

      direction = nextDirection;
    }

    // Updated draw function to handle the on-canvas button
    function draw() {
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      gradient.addColorStop(0, "#0d1b2a");
      gradient.addColorStop(1, "#1b263b");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (fullscreen && !gameRunning) {
          drawStartButton();
      } else if (gameRunning) {
          drawGrid();
          drawFood();
          drawKey();
          drawSnake();
          drawScore();
      }
    }

    function gameLoop() {
      update();
      draw();
    }

    function startGame() {
      resetGame();
      gameRunning = true;
      startBtn.style.display = "none";
      pauseBtn.style.display = "inline-block";
      resumeBtn.style.display = "none";
      restartBtn.style.display = "none";
      clearInterval(gameInterval);
      gameInterval = setInterval(gameLoop, speed);
      draw(); // Initial draw to start the loop
    }

    function pauseGame() {
      clearInterval(gameInterval);
      gameRunning = false;
      pauseBtn.style.display = "none";
      resumeBtn.style.display = "inline-block";
    }

    function resumeGame() {
      if (!gameRunning) {
        gameRunning = true;
        gameInterval = setInterval(gameLoop, speed);
        pauseBtn.style.display = "inline-block";
        resumeBtn.style.display = "none";
      }
    }

    function gameOver() {
      clearInterval(gameInterval);
      gameRunning = false;
      alert("Game Over!\nScore: " + score);
      restartBtn.style.display = "inline-block";
      pauseBtn.style.display = "none";
      resumeBtn.style.display = "none";
    }

    document.addEventListener("keydown", (e) => {
      const key = e.key.toLowerCase();
      if ((key === "arrowup" || key === "w") && direction.y !== 1) nextDirection = { x: 0, y: -1 };
      if ((key === "arrowdown" || key === "s") && direction.y !== -1) nextDirection = { x: 0, y: 1 };
      if ((key === "arrowleft" || key === "a") && direction.x !== 1) nextDirection = { x: -1, y: 0 };
      if ((key === "arrowright" || key === "d") && direction.x !== -1) nextDirection = { x: 1, y: 0 };
    });

    let touchStartX = 0, touchStartY = 0;
    let touchEndX = 0, touchEndY = 0;

    canvas.addEventListener("touchstart", (e) => {
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
    });

    canvas.addEventListener("touchend", (e) => {
      const touch = e.changedTouches[0];
      touchEndX = touch.clientX;
      touchEndY = touch.clientY;
      handleSwipe();
    });

    function handleSwipe() {
      const dx = touchEndX - touchStartX;
      const dy = touchEndY - touchStartY;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 30 && direction.x !== -1) nextDirection = { x: 1, y: 0 };
        if (dx < -30 && direction.x !== 1) nextDirection = { x: -1, y: 0 };
      } else {
        if (dy > 30 && direction.y !== -1) nextDirection = { x: 0, y: 1 };
        if (dy < -30 && direction.y !== 1) nextDirection = { x: 0, y: -1 };
      }
    }

    // New event listener for canvas clicks
    canvas.addEventListener("click", (e) => {
        if (!gameRunning && fullscreen) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const btnWidth = 200;
            const btnHeight = 60;
            const btnX = (canvas.width / 2) - (btnWidth / 2);
            const btnY = (canvas.height / 2) - (btnHeight / 2);

            if (mouseX >= btnX && mouseX <= btnX + btnWidth &&
                mouseY >= btnY && mouseY <= btnY + btnHeight) {
                startGame();
            }
        }
    });

    function enterFullscreen() {
      if (canvas.requestFullscreen) {
        canvas.requestFullscreen();
      } else if (canvas.webkitRequestFullscreen) {
        canvas.webkitRequestFullscreen();
      } else if (canvas.msRequestFullscreen) {
        canvas.msRequestFullscreen();
      }
    }

    function exitFullscreen() {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    }

    fullscreenBtn.addEventListener("click", () => {
      if (!fullscreen) {
        enterFullscreen();
      } else {
        exitFullscreen();
      }
    });

    document.addEventListener("fullscreenchange", () => {
      fullscreen = !!document.fullscreenElement;
      resizeCanvas();
      document.getElementById("ui").style.display = fullscreen ? "none" : "block";
      document.querySelector(".side-panel").style.display = fullscreen ? "none" : "flex";
      // Redraw the canvas to show or hide the on-canvas button
      draw();
    });

    startBtn.addEventListener("click", startGame);
    pauseBtn.addEventListener("click", pauseGame);
    resumeBtn.addEventListener("click", resumeGame);
    restartBtn.addEventListener("click", startGame);
  </script>
</body>
</html>
